var F=new Function("try {return this===window;}catch(e){ return false;}");function m(n){return Object.prototype.toString.call(n)=="[object Function]"||Object.prototype.toString.call(n)=="[object AsyncFunction]"}function d(n){return Number(n)===n}function c(n,e=1e-9){return Math.round(n/e)*e}var x=n=>n,u=Symbol.for("sc-scheduling:queue-time"),a=Symbol.for("sc-scheduling:scheduler"),l=Symbol.for("sc-scheduling:compat-mode");function y(n,e,t){let i=n[e];n[e]=n[t],n[t]=i}var k=function(n,e){return n<e},I=function(n,e){return n>e},S=function(n,e){return n>e},M=function(n,e){return n<e},b=class{constructor(e=1e3){this._currentLength=1,this._heap=new Array(e+1),this._reverse=null,this.reverse=!1}get time(){return this._currentLength>1?this._heap[1][u]:1/0}get head(){return this._heap[1]}set reverse(e){e!==this._reverse&&(this._reverse=e,this._reverse===!0?(this._isLower=k,this._isHigher=S):(this._isLower=I,this._isHigher=M),this._buildHeap())}_bubbleUp(e){let t=this._heap[e],i=e,s=Math.floor(i/2),r=this._heap[s];for(;r&&this._isHigher(t[u],r[u]);)y(this._heap,i,s),i=s,s=Math.floor(i/2),r=this._heap[s]}_bubbleDown(e){let t=this._heap[e],i=e,s=i*2,r=s+1,o=this._heap[s],h=this._heap[r];for(;o&&this._isLower(t[u],o[u])||h&&this._isLower(t[u],h[u]);){let f;h?f=this._isHigher(o[u],h[u])?s:r:f=s,y(this._heap,i,f),i=f,s=i*2,r=s+1,o=this._heap[s],h=this._heap[r]}}_buildHeap(){let e=Math.floor((this._currentLength-1)/2);for(let t=e;t>0;t--)this._bubbleDown(t)}_sanitizeTime(e){return Number.isFinite(e)?e=c(e):(Math.abs(e)!==1/0&&console.warn(`PriorityQueue: time is not a number: "${e}" (overriden to Infinity). This probably shows an error in your implementation.`),e=this.reverse?-1/0:1/0),e}add(e,t){return t=this._sanitizeTime(t),e[u]=t,this._heap[this._currentLength]=e,this._bubbleUp(this._currentLength),this._currentLength+=1,this.time}move(e,t){let i=this._heap.indexOf(e);if(i!==-1){t=this._sanitizeTime(t),e[u]=t;let s=this._heap[Math.floor(i/2)];s&&this._isHigher(t,s[u])?this._bubbleUp(i):this._bubbleDown(i)}return this.time}remove(e){let t=this._heap.indexOf(e);if(t!==-1){let i=this._currentLength-1;if(t===i)this._heap[i]=void 0;else if(y(this._heap,t,i),this._heap[i]=void 0,t===1)this._bubbleDown(1);else{let s=this._heap[t],r=this._heap[Math.floor(t/2)];r&&this._isHigher(s[u],r[u])?this._bubbleUp(t):this._bubbleDown(t)}delete e[u],this._currentLength=i}return this.time}clear(){for(let e=1;e<this._currentLength;e++)delete this._heap[e][u];this._currentLength=1,this._heap=new Array(this._heap.length)}has(e){return this._heap.includes(e)}},w=b;var T=class{constructor(){this._dt=0}get dt(){return this._dt}},g=class{constructor(e,{period:t=.025,lookahead:i=.1,queueSize:s=1e3,currentTimeToAudioTimeFunction:r=x,maxEngineRecursion:o=100,verbose:h=!1}={}){if(!m(e))throw new Error("[sc-scheduling] Invalid value for `getTimeFunction` in `new Scheduler(getTimeFunction)`, should be a function returning a time in seconds");this._queue=new w(s),this._engines=new Set,this._getTimeFunction=e,this._period=-1/0,this._lookahead=1/0,this._currentTimeToAudioTimeFunction=r,this._maxEngineRecursion=o,this._verbose=h,this._currentTime=null,this._nextTime=1/0,this._timeoutId=null,this._engineTimeCounterMap=new Map,this._tickInfos=new T,this.period=t,this.lookahead=i,this._tick=this._tick.bind(this)}get period(){return this._period}set period(e){if(e<0||e>=this.lookahead)throw new Error("[sc-scheduling] Invalid value for period, period must be strictly positive and lower than lookahead");this._period=e}get lookahead(){return this._lookahead}set lookahead(e){if(e<0||e<=this.period)throw new Error("[sc-scheduling] Invalid value for lookahead, lookahead must be strictly positive and greater than period");this._lookahead=e}get currentTime(){return this._currentTime||this._getTimeFunction()+this.lookahead}get audioTime(){return this._currentTimeToAudioTimeFunction(this.currentTime)}has(e){return e[l]&&(e=e[l]),this._engines.has(e)}defer(e,t){let i=(s,r,o)=>(setTimeout(()=>{let h=this._getTimeFunction();o._dt=s-h,e(s,r,o)},Math.ceil(o.dt*1e3)),null);this.add(i,t)}add(e,t){if(m(e.advanceTime)&&(e[l]===void 0&&(e[l]=e.advanceTime.bind(e)),e=e[l]),!m(e))throw delete e[a],new Error("[sc-scheduler] Invalid argument for scheduler.add(engine, time), engine should be a function");if(!d(t))throw new Error("[sc-scheduler] Invalid time for scheduler.add(engine, time), time should be a number");if(e[a]!==void 0)throw e[a]!==this?new Error("[sc-scheduler] Engine cannot be added to this scheduler, it has already been added to another scheduler"):new Error("[sc-scheduler] Engine has already been added to this scheduler");e[a]=this,this._engines.add(e),this._engineTimeCounterMap.set(e,{time:null,counter:0}),this._queue.add(e,t);let i=this._queue.time;this._resetTick(i,!0)}reset(e,t){if(e[l]&&(e=e[l]),e[a]!==void 0&&e[a]!==this)throw new Error("[sc-scheduler] Engine cannot be reset on this scheduler, it has been added to another scheduler");d(t)?this._queue.move(e,t):this._remove(e);let i=this._queue.time;this._resetTick(i,!0)}remove(e){if(e[l]&&(e=e[l]),e[a]!==void 0&&e[a]!==this)throw new Error("[sc-scheduler] Engine cannot be removed from this scheduler, it has been added to another scheduler");this._remove(e);let t=this._queue.time;this._resetTick(t,!0)}clear(){for(let e of this._engines)delete e[a];this._queue.clear(),this._engines.clear(),this._engineTimeCounterMap.clear(),this._resetTick(1/0,!1)}_remove(e){delete e[a],this._queue.remove(e),this._engines.delete(e),this._engineTimeCounterMap.delete(e)}_tick(){let e=this._getTimeFunction(),t=this._queue.time;for(this._timeoutId=null;t<=e+this.lookahead;){let i=this._queue.head,s=this._engineTimeCounterMap.get(i);this._currentTime=t,this._tickInfos._dt=t-e;let r=this._currentTimeToAudioTimeFunction(t),o=i(t,r,this._tickInfos);o===s.time?(s.counter+=1,s.counter>=this._maxEngineRecursion&&(console.warn(`[sc-scheduling] maxEngineRecursion (${this._maxEngineRecursion}) for the same engine at the same time: ${o} has been reached. This is generally due to a implementation issue, thus the engine has been discarded. If you know what you are doing, you should consider increasing the maxEngineRecursion option.`),o=1/0)):(s.time=o,s.counter=1),d(o)?this._queue.move(i,o):this._remove(i),t=this._queue.time}this._currentTime=null,this._resetTick(t,!1)}_resetTick(e,t){let i=this._nextTime;if(this._nextTime=e,clearTimeout(this._timeoutId),this._nextTime!==1/0){this._verbose&&i===1/0&&console.log("[sc-scheduling] > scheduler start");let s=this._getTimeFunction(),r=this._nextTime-s,o=t?.001:this.period,h=Math.max(r-this.lookahead,o);this._timeoutId=setTimeout(this._tick,Math.ceil(h*1e3))}else this._verbose&&i!==1/0&&console.log("[sc-scheduling] > scheduler stop")}},v=g;var p=class{constructor(){this.state={time:0,position:0,speed:0,loop:!1,loopStart:0,loopEnd:1/0},this.scheduledEvents=[],this._speed=1}get next(){return this.scheduledEvents[0]||null}get loopStart(){return this.state.loopStart}set loopStart(e){this.state.loopStart=e}get loopEnd(){return this.state.loopStart}set loopEnd(e){this.state.loopEnd=e}add(e){if(e.type!=="play"&&e.type!=="pause"&&e.type!=="seek"&&e.type!=="cancel"&&e.type!=="loop"&&e.type!=="speed")throw new Error(`Invalid event type: "${e.type}"`);if(this.state&&this.state.time>e.time)return console.error("[transportMixin] cannot schedule event in the past, aborting..."),null;if(e.type==="cancel")return this.scheduledEvents=this.scheduledEvents.filter(i=>i.time<e.time),e;this.scheduledEvents.push(e),this.scheduledEvents.sort((i,s)=>{if(i.time<s.time)return-1;if(i.time>s.time)return 1;if(i.time===s.time)return 0});let t=this.state.type;return this.scheduledEvents=this.scheduledEvents.filter((i,s)=>i.type==="seek"||i.type==="loop"||i.type==="speed"?!0:i.type!==t?(t=i.type,!0):!1),this.scheduledEvents.indexOf(e)!==-1?e:null}dequeue(){let e=this.next,t=Object.assign({},this.state);switch(t.type=e.type,t.time=e.time,t.position=this.getPositionAtTime(e.time),e.type){case"play":t.speed=this._speed;break;case"pause":t.speed=0;break;case"seek":t.position=e.position;break;case"loop":t.loop=e.loop;break;case"speed":this._speed=e.speed,t.speed>0&&(t.speed=e.speed);break}return this.scheduledEvents.shift(),this.state=t,Object.assign({},this.state)}getPositionAtTime(e){if(!Number.isFinite(e))return 1/0;let t=this.state,i=t.position+(e-t.time)*t.speed,s=t.position;if(t.loop&&i>=t.loopEnd){i-=t.loopStart,i=i%(t.loopEnd-t.loopStart),i+=t.loopStart;let r=i-t.loopStart;t.time=e-r,t.position=t.loopStart,s=Math.min(t.position,this.loopStart)}return Math.max(i,s)}getTimeAtPosition(e){return Number.isFinite(e)?this.state.speed===0?this.state.time:this.state.time+(e-this.state.position)/this.state.speed:1/0}};function E(n){JSON.parse(JSON.stringify(n))}var _=class{constructor(e){if(!(e instanceof v))throw new Error("[sc-scheduling] Invalid param, is not an instance of Scheduler");this.scheduler=e,this._eventQueue=new p,this._children=new Map,this._tick=this._tick.bind(this)}get currentTime(){return this.scheduler.currentTime}get audioTime(){return this.scheduler.audioTime}setState(e){this._eventQueue.state=e.currentState,this._eventQueue.scheduledEvents=e.scheduledEvents}getState(){return{currentState:E(this._eventQueue.state),scheduledEvents:E(this._eventQueue.scheduledEvents)}}set loopStart(e){this._eventQueue.loopStart=e}get loopStart(){return this._eventQueue.loopStart}set loopEnd(e){this._eventQueue.loopEnd=e}get loopEnd(){return this._eventQueue.loopEnd}play(e){let t={type:"play",time:c(e)};return this.addEvent(t)}pause(e){let t={type:"pause",time:c(e)};return this.addEvent(t)}seek(e,t){let i={type:"seek",time:c(e),position:t};return this.addEvent(i)}loop(e,t){let i={type:"loop",time:c(e),loop:t};return this.addEvent(i)}speed(e,t){let i={type:"speed",time:c(e),speed:t};return this.addEvent(i)}cancel(e){let t={type:"cancel",time:c(e)};return this.addEvent(t)}addEvents(e){return e.map(t=>this.addEvent(t))}addEvent(e){let t=this._eventQueue.next,i=this._eventQueue.add(e);return i!==null&&i.type!=="cancel"&&(this.scheduler.has(this._tick)?(!t||i.time<t.time)&&this.scheduler.reset(this._tick,i.time):this.scheduler.add(this._tick,this._eventQueue.next.time)),i}getPositionAtTime(e){return c(this._eventQueue.getPositionAtTime(e))}_tick(e,t,i){let s=this._eventQueue.dequeue();for(let r of this._children.keys()){let o;try{o=r.onTransportEvent(s,s.position,t,i)}catch(h){console.log(h)}if(d(o)){let h=this._eventQueue.getTimeAtPosition(o);this.scheduler.reset(r,h)}}return this._eventQueue.next?this._eventQueue.next.time:1/0}add(e){if(this._children.has(e))throw new Error("already added to transport");let t=e.advanceTime;t||(t=()=>1/0),e.advanceTime=(i,s,r)=>{if(this._eventQueue.state.speed>0){let o=this.getPositionAtTime(i),h=t.call(e,o,s,r);return d(h)?this._eventQueue.getTimeAtPosition(h):1/0}},this._children.set(e,t),e.onTransportEvent||(e.onTransportEvent=(i,s,r,o)=>i.speed>0?s:1/0),this.scheduler.add(e,1/0)}has(e){return this._children.has(e)}remove(e){this.scheduler.remove(e);let t=this._children.get(e);e.advanceTime=t,this._children.delete(e)}};export{v as Scheduler,_ as Transport};